<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Ting-En Liao</title><link>https://xxoooxx345678.github.io/</link><description>Recent content on Ting-En Liao</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 18 Jul 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://xxoooxx345678.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>OS organization and system calls</title><link>https://xxoooxx345678.github.io/posts/self-study/operating-system/notes/os-organization-and-system-calls/</link><pubDate>Mon, 18 Jul 2022 00:00:00 +0000</pubDate><guid>https://xxoooxx345678.github.io/posts/self-study/operating-system/notes/os-organization-and-system-calls/</guid><description>Chapter 2 : Operating system organization An operating system must fulfill three requirements: multiplexing, isolation, and interaction
2.1 Abstracting physical resources Why do we need operating system ? One could implement the system calls as a library, then each app could even have its own library tailored to its needs. Apps could directly interact with HW resources and use those resources int the best way for apps. (OS for Embedded devices or real-time systems) The downside of this approach is, multiplexing will be troublesome.</description></item><item><title>Lab: Xv6 and Unix utilities</title><link>https://xxoooxx345678.github.io/posts/self-study/operating-system/labs/lab1/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://xxoooxx345678.github.io/posts/self-study/operating-system/labs/lab1/</guid><description>sleep 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &amp;#34;kernel/types.h&amp;#34; #include &amp;#34;kernel/stat.h&amp;#34; #include &amp;#34;user/user.h&amp;#34; int main(int argc, char *argv[]) { if (argc &amp;lt; 2) { printf(&amp;#34;[Error] missing operand\n&amp;#34;); exit(-1); } int sleep_time = atoi(argv[1]); sleep(sleep_time); exit(0); } pingpong 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 #include &amp;#34;kernel/types.</description></item><item><title>Reference for MIT 6.S081</title><link>https://xxoooxx345678.github.io/posts/self-study/operating-system/reference/</link><pubDate>Fri, 01 Jul 2022 00:00:00 +0000</pubDate><guid>https://xxoooxx345678.github.io/posts/self-study/operating-system/reference/</guid><description> 對岸大老的彙整</description></item><item><title>修課心得</title><link>https://xxoooxx345678.github.io/posts/nycu/course/overall/</link><pubDate>Mon, 27 Jun 2022 00:00:00 +0000</pubDate><guid>https://xxoooxx345678.github.io/posts/nycu/course/overall/</guid><description>Preliminary 善用右邊的Table of Contents 甜涼補都是5分為滿分 修課感受每個人都不同，這只是我個人的意見，慎入 有些課太久以前修的了，簡略寫 必修 全校必修 微積分 任課教師: 石至文 修課學期: 1071 &amp;amp; 1072 開課單位: 微積分小組 授課方式: 照著課綱交、使用板書，課本上的證明幾乎都會證一遍 微一的時候有一次翻轉教學，但效果不好，微二就沒了 作業 每章節都會勾習題，寫好要交給助教 助教改的蠻嚴的 考試 偏難，記得微二第一次期中考平均30幾 (然後我比平均還低 😂) 雖然他出的期中考我考的都不好，但大會考我差一點拿微積分獎ㄏ 成績 微一: B- 微二: B 總結 甜🍬: 2 涼🧊: 2.5 補📖: 4 物理 任課教師: 吳光雄 修課學期: 1071 &amp;amp; 1072 開課單位: 物理小組 授課方式: 板書(? 我都沒在上課 我給忘了== 作業 沒作業(應該吧? 考試 助教說比其他班都還要難很多 但是助教會洩題，所以平均看起來還可以 會洩題的助教畢業後你各位耗子尾汁 成績 物理一: B+ 物理二: A 總結 甜🍬: 3.5 涼🧊: 4 補📖: 2 資工必修 線性代數 任課教師: 翁志文 修課學期: 1071 &amp;amp; 1072 開課單位: 應數系 授課方式: 使用很經典的Friedberg的書 板書，大多都講證明，沒甚麼講習題 老師教得不怎麼好 作業 寫習題給助教改 考試 小考: 選習題來考 期中期末: 大多都證明 成績 線代一: B+ 線代二: B+ 總結 甜🍬: 3.</description></item></channel></rss>